base.counts <- rpois(n= length(t),lambda = base.avr)
plot(t,base.counts)
base.avr <- sin(2*pi*t/53)/2 +0.5
# plot(t,base.avr)
base.counts <- rpois(n= length(t),lambda = base.avr)
#plot(t,base.counts)
plot(t,base.counts)
plot(t,base.counts,ylim=c(0.15))
plot(t,base.counts,ylim=c(0,15))
base.avr <- sin(2*pi*t/53)/2 +0.75
# plot(t,base.avr)
base.counts <- rpois(n= length(t),lambda = base.avr)
#plot(t,base.counts,ylim=c(0,15))
plot(t,base.counts,ylim=c(0,15))
outbreak.start <- 100 # the day the outbreak started
outbreak.shape <- c(2,4,5,2,)# number of outbreak related syndromes on day 1, 2.
total.counts <- base.counts + c(rep(0,outbreak.start),c(outbreak.shape),(length(t)+outbreak.start+length(outbreak.shape)))
outbreak.start <- 100 # the day the outbreak started
outbreak.shape <- c(4,5,9,7,4)# number of outbreak related syndromes on day 1, 2. From Rachels simulation
total.counts <- base.counts + c(rep(0,outbreak.start),c(outbreak.shape),(length(t)+outbreak.start+length(outbreak.shape)))
total.counts <- base.counts + c(rep(0,outbreak.start),c(outbreak.shape),rep(0,(length(t)-outbreak.start-length(outbreak.shape)))
total.counts <- base.counts + c(rep(0,outbreak.start),c(outbreak.shape),rep(0,(length(t)-outbreak.start-length(outbreak.shape))))
length(t)-outbreak.start-length(outbreak.shape)
length(t)-outbreak.start-length(outbreak.shape)
length(outbreak.shape)
t <- seq(1,3650) # time in days weeks or whatever"
base.avr <- sin(2*pi*t/365)/2 +0.75
# plot(t,base.avr)
base.counts <- rpois(n= length(t),lambda = base.avr)
#plot(t,base.counts,ylim=c(0,15))
outbreak.start <- 100 # the day the outbreak started
outbreak.shape <- c(4,5,9,7,4)# number of outbreak related syndromes on day 1, 2. From Rachels simulation
total.counts <- base.counts + c(rep(0,outbreak.start),c(outbreak.shape),rep(0,(length(t)-outbreak.start-length(outbreak.shape))))
plot(t,total.counts,ylim=c(0,15))
t <- seq(1,365) # time in days weeks or whatever"
base.avr <- sin(2*pi*t/365)/2 +0.75
# plot(t,base.avr)
base.counts <- rpois(n= length(t),lambda = base.avr)
#plot(t,base.counts,ylim=c(0,15))
outbreak.start <- 100 # the day the outbreak started
outbreak.shape <- c(4,5,9,7,4)# number of outbreak related syndromes on day 1, 2. From Rachels simulation
total.counts <- base.counts + c(rep(0,outbreak.start),c(outbreak.shape),rep(0,(length(t)-outbreak.start-length(outbreak.shape))))
#plot(t,total.counts,ylim=c(0,15))
plot(t,total.counts,ylim=c(0,15))
p.rep.if.not <- rep(NA,length(p.reported)#this vector is the probability that a case not reported on day i-1 is reported on day i
p.rep.if.not[1]<-p.reported[1]
for(i<-2:length(p.reported)){
p.rep.if.not[i]<-    p.reported[i]-p.reported[i-1])/(1-p.reported[i-1])
}
p.rep.if.not <- rep(NA,length(p.reported)#this vector is the probability that a case not reported on day i-1 is reported on day i
p.rep.if.not[1]<-p.reported[1]
for(i<-2:length(p.reported)){
p.rep.if.not[i]<-    (p.reported[i]-p.reported[i-1])/(1-p.reported[i-1])
}
p.reported <- c(0,0.2,0.5,0.7,0.75,0.8,0.85,0.9,0.95,0.975,0.99,0.995,1)# histogram of cumulative probability of a case being
#reported on day i after happening.i=1 is day of incidence
p.rep.if.not <- rep(NA,length(p.reported)#this vector is the probability that a case not reported on day i-1 is reported on day i
p.rep.if.not[1]<-p.reported[1]
p.reported <- c(0,0.2,0.5,0.7,0.75,0.8,0.85,0.9,0.95,0.975,0.99,0.995,1)# histogram of cumulative probability of a case being
#reported on day i after happening.i=1 is day of incidence
p.rep.if.not <- rep(NA,length(p.reported))#this vector is the probability that a case not reported on day i-1 is reported on day i
p.rep.if.not[1]<-p.reported[1]
for(i<-2:length(p.reported)){
p.rep.if.not[i]<- (p.reported[i]-p.reported[i-1])/(1-p.reported[i-1])
}
p.rep.if.not <- rep(NA,length(p.reported))#this vector is the probability that a case not reported on day i-1 is reported on day i
p.rep.if.not[1]<-p.reported[1]
p.rep.if.not
for(i in 2:length(p.reported)){
p.rep.if.not[i]<- (p.reported[i]-p.reported[i-1])/(1-p.reported[i-1])
}
p.rep.if.not
seen.counts <- matrix(, nrow = t, ncol = length(p.reported))
true.counts <- totalcounts # or base.counts
seen.counts <- matrix(, nrow = t, ncol = length(p.reported))#number of counts on day i seen on day j after (j=1 is day of incidence)
for(i in 1:lenght(t)){
for(j in 1:length(p.rep.if.not)){
seen.counts[i.j]<. 1
}
}
true.counts <- totalcounts # or base.counts
seen.counts <- matrix(, nrow = t, ncol = length(p.reported))#number of counts on day i seen on day j after (j=1 is day of incidence)
for(i in 1:lenght(t)){
for(j in 1:length(p.rep.if.not)){
seen.counts[i.j]<- 1
}
}
for(i in 1:length(t)){
for(j in 1:length(p.rep.if.not)){
seen.counts[i.j]<- 1
}
}
for(i in 1:length(t)){
for(j in 1:length(p.rep.if.not)){
seen.counts[i,j]<- 1
}
}
for(i in 1:length(t)){
for(j in 1:length(p.rep.if.not)){
seen.counts[j,i]<- 1
}
}
seen.counts
true.counts <- totalcounts # or base.counts
seen.counts <- matrix(, nrow = t, ncol = length(p.reported))#number of counts on day i seen on day j after (j=1 is day of incidence)
seen.counts
length(p.reported)
seen.counts <- matrix(, nrow = length(t), ncol = length(p.reported))#number of counts on day i seen on day j after (j=1 is day of incidence)
for(i in 1:length(t)){
for(j in 1:length(p.rep.if.not)){
seen.counts[j,i]<- 1
}
}
seen.counts <- matrix(, nrow = length(t), ncol = length(p.reported))#number of counts on day i seen on day j after (j=1 is day of incidence)
for(i in 1:length(t)){
for(j in 1:length(p.rep.if.not)){
seen.counts[i,j]<- 1
}
}
seen.counts
seen.counts <- matrix(, nrow = length(t), ncol = length(p.reported))#number of counts on day i seen on day j after (j=1 is day of incidence)
for(i in 1:length(t)){
seen.counts[i,1]<- <- true.counts[i]*p.rep.if.not[1]
for(j in 2:length(p.rep.if.not)){
seen.counts[i,j]<-2
}
}
seen.counts <- matrix(, nrow = length(t), ncol = length(p.reported))#number of counts on day i seen on day j after (j=1 is day of incidence)
for(i in 1:length(t)){
seen.counts[i,1] <- true.counts[i]*p.rep.if.not[1]
for(j in 2:length(p.rep.if.not)){
seen.counts[i,j]<-2
}
}
true.counts <- totalcounts # or base.counts
seen.counts <- matrix(, nrow = length(t), ncol = length(p.reported))#number of counts on day i seen on day j after (j=1 is day of incidence)
for(i in 1:length(t)){
seen.counts[i,1] <- true.counts[i]*p.rep.if.not[1]
for(j in 2:length(p.rep.if.not)){
seen.counts[i,j]<-2
}
}
total.counts <- base.counts + c(rep(0,outbreak.start),c(outbreak.shape),rep(0,(length(t)-outbreak.start-length(outbreak.shape))))
p.reported <- c(0,0.2,0.5,0.7,0.75,0.8,0.85,0.9,0.95,0.975,0.99,0.995,1)# histogram of cumulative probability of a case being
#reported on day i after happening.i=1 is day of incidence
p.rep.if.not <- rep(NA,length(p.reported))#this vector is the probability that a case not reported on day i-1 is reported on day i
p.rep.if.not[1]<-p.reported[1]#
for(i in 2:length(p.reported)){
p.rep.if.not[i]<- (p.reported[i]-p.reported[i-1])/(1-p.reported[i-1])
}
true.counts <- totalcounts # or base.counts
true.counts <- total.counts # or base.counts
seen.counts <- matrix(, nrow = length(t), ncol = length(p.reported))#number of counts on day i seen on day j after (j=1 is day of incidence)
for(i in 1:length(t)){
seen.counts[i,1] <- true.counts[i]*p.rep.if.not[1]
for(j in 2:length(p.rep.if.not)){
seen.counts[i,j]<-2
}
}
seen.counts
rbinom(n=1,size=3,prob=0.3)
rbinom(n=1,size=unseen,prob=p.rep.if.not[j]
rbinom(n=1,size=unseen,prob=p.rep.if.not[j]
rbinom(n=1,size=unseen,prob=0.3)
rbinom(n=1,size=3,prob=0.3)
rbinom(n=10,size=3,prob=0.3)
for(i in 1:length(t)){
seen.counts[i,1] <- true.counts[i]*p.rep.if.not[1]
for(j in 2:length(p.rep.if.not)){
unseen <- total.counts[i,j-1]- seen.counts[i,j-1]
seen.counts[i,j]<-seen.counts[i,j-1]+ rbinom(n=1,size=unseen,prob=p.rep.if.not[j])
}
}
seen.counts
t <- seq(1,10) # time in days weeks or whatever"
base.avr <- sin(2*pi*t/365)/2 +0.75
# plot(t,base.avr)
base.counts <- rpois(n= length(t),lambda = base.avr)
#plot(t,base.counts,ylim=c(0,15))
outbreak.start <- 100 # the day the outbreak started
outbreak.shape <- c(4,5,9,7,4)# number of outbreak related syndromes on day 1, 2. From Rachels simulation
total.counts <- base.counts + c(rep(0,outbreak.start),c(outbreak.shape),rep(0,(length(t)-outbreak.start-length(outbreak.shape))))
#plot(t,total.counts,ylim=c(0,15))
p.reported <- c(0,0.2,0.5,0.7,0.75,0.8,0.85,0.9,0.95,0.975,0.99,0.995,1)# histogram of cumulative probability of a case being
#reported on day i after happening.i=1 is day of incidence
p.rep.if.not <- rep(NA,length(p.reported))#this vector is the probability that a case not reported on day i-1 is reported on day i
p.rep.if.not[1]<-p.reported[1]#
for(i in 2:length(p.reported)){
p.rep.if.not[i]<- (p.reported[i]-p.reported[i-1])/(1-p.reported[i-1])
}
true.counts <- total.counts # or base.counts
seen.counts <- matrix(, nrow = length(t), ncol = length(p.reported))#number of counts on day i seen on day j after (j=1 is day of incidence)
true.counts
t <- seq(1,15) # time in days weeks or whatever"
base.avr <- sin(2*pi*t/365)/2 +0.75
# plot(t,base.avr)
base.counts <- rpois(n= length(t),lambda = base.avr)
#plot(t,base.counts,ylim=c(0,15))
outbreak.start <- 3 # the day the outbreak started
outbreak.shape <- c(4,5,9,7,4)# number of outbreak related syndromes on day 1, 2. From Rachels simulation
total.counts <- base.counts + c(rep(0,outbreak.start),c(outbreak.shape),rep(0,(length(t)-outbreak.start-length(outbreak.shape))))
#plot(t,total.counts,ylim=c(0,15))
p.reported <- c(0,0.2,0.5,0.7,0.75,0.8,0.85,0.9,0.95,0.975,0.99,0.995,1)# histogram of cumulative probability of a case being
#reported on day i after happening.i=1 is day of incidence
p.rep.if.not <- rep(NA,length(p.reported))#this vector is the probability that a case not reported on day i-1 is reported on day i
p.rep.if.not[1]<-p.reported[1]#
for(i in 2:length(p.reported)){
p.rep.if.not[i]<- (p.reported[i]-p.reported[i-1])/(1-p.reported[i-1])
}
true.counts <- total.counts # or base.counts
seen.counts <- matrix(, nrow = length(t), ncol = length(p.reported))#number of counts on day i seen on day j after (j=1 is day of incidence)
true.counts
seen.counts
for(i in 1:length(t)){
seen.counts[i,1] <- true.counts[i]*p.rep.if.not[1]
for(j in 2:length(p.rep.if.not)){
unseen <- total.counts[i,j-1]- seen.counts[i,j-1]
seen.counts[i,j]<-seen.counts[i,j-1] + rbinom(n=1,size=unseen,prob=p.rep.if.not[j])
}
}
for(i in 1:length(t)){
seen.counts[i,1] <- true.counts[i]*p.rep.if.not[1]
for(j in 2:length(p.rep.if.not)){
unseen <- true.counts[i]- seen.counts[i,j-1]
seen.counts[i,j]<-seen.counts[i,j-1] + rbinom(n=1,size=unseen,prob=p.rep.if.not[j])
}
}
seen.counts
p.rep.if.not
p.rep.if.not[1]
true.counts <- total.counts # or base.counts
seen.counts <- matrix(, nrow = length(t), ncol = length(p.reported))#number of counts on day i seen on day j after (j=1 is day of incidence)
for(i in 1:length(t)){
seen.counts[i,1] <- true.counts[i]*p.rep.if.not[1]
for(j in 2:length(p.rep.if.not)){
unseen <- true.counts[i]- seen.counts[i,j-1]
seen.counts[i,j]<-seen.counts[i,j-1] + rbinom(n=1,size=unseen,prob=p.rep.if.not[j])
}
}
seen.counts
## Baseline and outbreak with delayed reporting
t <- seq(1,50) # time in days weeks or whatever set to 365 to give year
base.avr <- sin(2*pi*t/365)/2 +0.75 # the average number of cases on day t (from time series analysis)
# plot(t,base.avr)
base.counts <- rpois(n= length(t),lambda = base.avr)# the simulated nuber of cases on day t. I assume Poisson but it may be e.g. Negbinom too
#plot(t,base.counts,ylim=c(0,15))
outbreak.start <- 3 # the day the outbreak started
outbreak.shape <- c(4,5,9,7,4)# number of outbreak related syndromes on day 1, 2. From Rachels simulation
total.counts <- base.counts + c(rep(0,outbreak.start),c(outbreak.shape),rep(0,(length(t)-outbreak.start-length(outbreak.shape))))
#plot(t,total.counts,ylim=c(0,15))
p.reported <- c(0,0.2,0.5,0.7,0.75,0.8,0.85,0.9,0.95,0.975,0.99,0.995,1)# histogram of cumulative probability of a case being
#reported on day i after happening.i=1 is day of incidence
p.rep.if.not <- rep(NA,length(p.reported))#this vector is the probability that a case not reported on day i-1 is reported on day i
p.rep.if.not[1]<-p.reported[1]#
for(i in 2:length(p.reported)){
p.rep.if.not[i]<- (p.reported[i]-p.reported[i-1])/(1-p.reported[i-1])
}
true.counts <- total.counts # or base.counts
seen.counts <- matrix(, nrow = length(t), ncol = length(p.reported))#number of counts on day i seen on day j after (j=1 is day of incidence)
for(i in 1:length(t)){
seen.counts[i,1] <- true.counts[i]*p.rep.if.not[1]
for(j in 2:length(p.rep.if.not)){
unseen <- true.counts[i]- seen.counts[i,j-1]
seen.counts[i,j]<-seen.counts[i,j-1] + rbinom(n=1,size=unseen,prob=p.rep.if.not[j])
}
}
plot(t,true.counts,ylim=c(0,15))
plot(t,true.counts,ylim=c(0,15))
lines(t,true.counts,col=1)
lines(t,seen.counts[,2],col=2)
lines(t,true.counts,col=1)
lines(t,seen.counts[,2],col=2)
lines(t,seen.counts[,5],col=3)
x = rdirichlet(10, c(1,2,3))
install.packages("LCA")
require(LCA)
x = rdirichlet(10, c(1,2,3))
install.packages("ica")
require(ica)
x = rdirichlet(10, c(1,2,3))
install.packages("gtools")
require(gtools)
x = rdirichlet(10, c(1,2,3))
x
x[1,]
y = ddirichlet(x[1,], c(1,2,3))
y
y = ddirichlet(x, c(1,2,3))
y
require(graphics)
# A Color Wheel
pie(rep(1, 12), col = rainbow(12))
##------ Some palettes ------------
demo.pal <-
function(n, border = if (n < 32) "light gray" else NA,
main = paste("color palettes;  n=", n),
ch.col = c("rainbow(n, start=.7, end=.1)", "heat.colors(n)",
"terrain.colors(n)", "topo.colors(n)",
"cm.colors(n)"))
{
nt <- length(ch.col)
i <- 1:n; j <- n / nt; d <- j/6; dy <- 2*d
plot(i, i+d, type = "n", yaxt = "n", ylab = "", main = main)
for (k in 1:nt) {
rect(i-.5, (k-1)*j+ dy, i+.4, k*j,
col = eval(parse(text = ch.col[k])), border = border)
text(2*j,  k * j + dy/4, ch.col[k])
}
}
n <- if(.Device == "postscript") 64 else 16
# Since for screen, larger n may give color allocation problem
demo.pal(n)
install.packages("randomForest")
data(iris)
require(randomForests)
require(randomForest)
data(iris)
iris.rf <- randomForest(iris[,-5], iris[,5], prox=TRUE)
iris.p <- classCenter(iris[,-5], iris[,5], iris.rf$prox)
plot(iris[,3], iris[,4], pch=21, xlab=names(iris)[3], ylab=names(iris)[4],
bg=c("red", "blue", "green")[as.numeric(factor(iris$Species))],
main="Iris Data with Prototypes")
points(iris.p[,3], iris.p[,4], pch=21, cex=2, bg=c("red", "blue", "green"))
iris.rf
View(iris)
View(iris)
confusion(iris)
data(airquality)
set.seed(131)
ozone.rf <- randomForest(Ozone ~ ., data=airquality, mtry=3,
importance=TRUE, na.action=na.omit)
print(ozone.rf)
ozone.rf
airquality[,1:130]
airquality[1:130,]
air.train <- airquality[1:130,]
air.test <- airquality[131:154,]
set.seed(131)
ozone.rf <- randomForest(Ozone ~ ., data=air.train, mtry=3,
importance=TRUE, na.action=na.omit)
print(ozone.rf)
predict(ozone.rf,air.test)
test.pred <- predict(ozone.rf,air.test)
air.test[,6]
data(airquality)
air.train <- airquality[1:130,]
air.test <- airquality[131:153,]
set.seed(131)
ozone.rf <- randomForest(Ozone ~ ., data=air.train, mtry=3,
importance=TRUE, na.action=na.omit)
print(ozone.rf)
test.pred <- predict(ozone.rf,air.test)
test-true <- air.test[,6]
air.train <- airquality[1:130,]
air.test <- airquality[131:153,]
set.seed(131)
ozone.rf <- randomForest(Ozone ~ ., data=air.train, mtry=3,
importance=TRUE, na.action=na.omit)
print(ozone.rf)
test.pred <- predict(ozone.rf,air.test)
test.true <- air.test[,6]
plot(test.true,test.pred)
head(iris)
head(airquality)
test.pred <- predict(ozone.rf,air.test)
test.true <- air.test[,1]
plot(test.true,test.pred)
plot(log10(test.true),log10(test.pred))
importance(ozone.rf, type=NULL, class=NULL, scale=TRUE, ...)
importance(ozone.rf, type=NULL, class=NULL, scale=TRUE)
importance(iris.rf, type=NULL, class=NULL, scale=TRUE)
importance(ozone.rf, type=1, class=NULL, scale=TRUE)
imp <- importance(ozone.rf, type=1, class=NULL, scale=TRUE)
imp
imp[1]
require(Binom)
install.packages("binom")
require(binom)
binom.bayes(x, n,
conf.level = 0.95,
type = c("highest", "central"),
prior.shape1 = 0.5,
prior.shape2 = 0.5,
tol = .Machine$double.eps^0.5,
maxit = 1000, ...)
x <- 0
n <- 10
binom.bayes(x, n,
conf.level = 0.95,
type = c("highest", "central"),
prior.shape1 = 0.5,
prior.shape2 = 0.5,
tol = .Machine$double.eps^0.5,
maxit = 1000)
n <- c(10,15,20,25,30,35,40,45,50,55,60,65
binom.bayes(x, n,
conf.level = 0.95,
type = c("highest", "central"),
prior.shape1 = 0.5,
prior.shape2 = 0.5,
tol = .Machine$double.eps^0.5,
maxit = 1000)
x <- 0
n <- c(10,15,20,25,30,35,40,45,50,55,60,65)
result <- c()
for( i in 1:length(n)){
result.temp<- binom.bayes(x, n[i],
conf.level = 0.95,
type = c("highest", "central"),
prior.shape1 = 0.5,
prior.shape2 = 0.5,
tol = .Machine$double.eps^0.5,
maxit = 1000)
result <- rbind(result,result.temp)
}
result
x <- 0
n <- 5*seq(1,20)
result <- c()
for( i in 1:length(n)){
result.temp<- binom.bayes(x, n[i],
conf.level = 0.95,
type = c("highest", "central"),
prior.shape1 = 0.5,
prior.shape2 = 0.5,
tol = .Machine$double.eps^0.5,
maxit = 1000)
result <- rbind(result,result.temp)
}
result
result$n
plot(result$n,result$upper)
require(binom)
x <- 1
n <- 5*seq(1,20)
result <- c()
for( i in 1:length(n)){
result.temp<- binom.bayes(x, n[i],
conf.level = 0.95,
type = c("highest", "central"),
prior.shape1 = 0.5,
prior.shape2 = 0.5,
tol = .Machine$double.eps^0.5,
maxit = 1000)
result <- rbind(result,result.temp)
}
plot(result$n,result$upper)
x <- 1
n <- 5*seq(1,20)
result <- c()
for( i in 1:length(n)){
result.temp<- binom.bayes(x, n[i],
conf.level = 0.95,
type = c("highest", "central"),
prior.shape1 = 0.5,
prior.shape2 = 0.5,
tol = .Machine$double.eps^0.5,
maxit = 1000)
result <- rbind(result,result.temp)
}
plot(result$n,result$upper)
points(result$n,result$lower,col=2)
result$lower
plot(result$n,result$upper)
points(result$n,result$lower,col=2)
plot(result$n,result$upper,ylim<- c(-0.1,1,))
points(result$n,result$lower,col=2)
plot(result$n,result$upper,ylim=c(-0.1,1,))
points(result$n,result$lower,col=2)
plot(result$n,result$upper,ylim=c(-0.1,1))
points(result$n,result$lower,col=2)
lines(c(0,100),c(0,0))
x <- 0
n <- 5*seq(1,20)
result <- c()
for( i in 1:length(n)){
result.temp<- binom.bayes(x, n[i],
conf.level = 0.95,
type = c("highest", "central"),
prior.shape1 = 0.5,
prior.shape2 = 0.5,
tol = .Machine$double.eps^0.5,
maxit = 1000)
result <- rbind(result,result.temp)
}
plot(result$n,result$upper,ylim=c(-0.1,1))
lines(c(0,100),c(0,0))
points(result$n,result$lower,col=2)
result
require(binom)
x <- 1
n <- 5*seq(1,20)
result <- c()
for( i in 1:length(n)){
result.temp<- binom.bayes(x, n[i],
conf.level = 0.95,
type = c("highest", "central"),
prior.shape1 = 0.5,
prior.shape2 = 0.5,
tol = .Machine$double.eps^0.5,
maxit = 1000)
result <- rbind(result,result.temp)
}
plot(result$n,result$upper,ylim=c(-0.1,1))
points(result$n,result$lower,col=2)
lines(c(0,100),c(0,0))
result
sample(c(rep(1,7),rep(2,6)),13,replacement=FALSE)
sample(c(rep(1,7),rep(2,6)),13,replace=FALSE)
sample(c(rep(1,5),rep(2,4)),13,replace=FALSE)
sample(c(rep(1,5),rep(2,4)),9,replace=FALSE)
setwd("H:/KMF/Joint_risk/JRS_server/JRS.git.clone")
